<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, viewport-fit=cover, user-scalable=yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="theme-color" content="#0b0b0c" id="themeColor" />
    <meta name="apple-mobile-web-app-title" content="primehaul" />

    <title>{{ title or "primehaul" }}</title>
    <link rel="stylesheet" href="/static/app.css?v=8" />
    <script>
      // Apply theme immediately to prevent flash
      (function(){
        var stored = localStorage.getItem('ph-theme');
        var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        var theme = stored || (prefersDark ? 'dark' : 'light');
        if(theme === 'light') {
          document.documentElement.classList.add('light-mode');
          document.body && document.body.classList.add('light-mode');
        }
      })();
    </script>
  </head>

  <body>
    <div class="app">
      <header class="nav">
        <div class="nav-inner">
          {% if back_url %}
            <a class="nav-back" href="{{ back_url }}" aria-label="Back">‹ Back</a>
          {% else %}
            <span class="nav-back ghost" aria-hidden="true">‹ Back</span>
          {% endif %}

          <div class="nav-center">
            {{ nav_title if nav_title else "primehaul" }}
          </div>

          <button class="voice-toggle" id="voiceToggle" aria-label="Toggle voice guide" title="Voice guide">
            <span class="voice-icon">On</span>
            <span class="voice-label">Voice</span>
          </button>
          <button class="theme-toggle" id="themeToggle" aria-label="Toggle light/dark mode" title="Toggle theme">
            <span class="theme-icon">Dark</span>
          </button>
        </div>

        {% if progress is not none %}
          <div class="nav-progress" aria-label="Progress">
            <div class="nav-progress-inner">
              <div class="nav-progress-bar" data-progress="{{ progress|default(0) }}"></div>
            </div>
          </div>
        {% endif %}
      </header>

      <main class="screen" role="main">
        {% block content %}{% endblock %}
      </main>

      {% block footer %}{% endblock %}
    </div>

    <script>
      (function () {
        // Prevent accidental double submits on mobile
        document.addEventListener(
          "submit",
          function (e) {
            const btn = e.target.querySelector('button[type="submit"]');
            if (btn) {
              btn.disabled = true;
              btn.classList.add("is-busy");
            }
          },
          true
        );

        // Progress bar width (avoid inline style with Jinja)
        const bar = document.querySelector(".nav-progress-bar[data-progress]");
        if (bar) {
          const p = Number(bar.getAttribute("data-progress") || "0");
          const clamped = Math.max(0, Math.min(100, p));
          bar.style.width = clamped + "%";
        }

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = themeToggle ? themeToggle.querySelector('.theme-icon') : null;
        const themeColor = document.getElementById('themeColor');

        function getStoredTheme() {
          return localStorage.getItem('ph-theme');
        }

        function getSystemTheme() {
          return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function getCurrentTheme() {
          return getStoredTheme() || getSystemTheme();
        }

        function applyTheme(theme) {
          if (theme === 'light') {
            document.documentElement.classList.add('light-mode');
            document.body.classList.add('light-mode');
            if (themeIcon) themeIcon.textContent = 'Light';
            if (themeColor) themeColor.setAttribute('content', '#f5f5f7');
          } else {
            document.documentElement.classList.remove('light-mode');
            document.body.classList.remove('light-mode');
            if (themeIcon) themeIcon.textContent = 'Dark';
            if (themeColor) themeColor.setAttribute('content', '#0b0b0c');
          }
        }

        function toggleTheme() {
          const current = getCurrentTheme();
          const next = current === 'dark' ? 'light' : 'dark';
          localStorage.setItem('ph-theme', next);
          applyTheme(next);
        }

        // Initialize theme
        applyTheme(getCurrentTheme());

        // Toggle button click
        if (themeToggle) {
          themeToggle.addEventListener('click', toggleTheme);
        }

        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
          if (!getStoredTheme()) {
            applyTheme(e.matches ? 'dark' : 'light');
          }
        });

        // =============================================
        // VOICE GUIDE FUNCTIONALITY (OpenAI TTS)
        // Instant start, browser-cached, mobile-safe
        // =============================================
        const voiceToggle = document.getElementById('voiceToggle');
        const voiceIcon = voiceToggle ? voiceToggle.querySelector('.voice-icon') : null;
        const voiceLabel = voiceToggle ? voiceToggle.querySelector('.voice-label') : null;
        let voiceEnabled = localStorage.getItem('ph-voice-guide') !== 'false';
        let currentAudio = null;
        let isSpeaking = false;
        let pendingRetry = null;

        function updateVoiceUI(loading) {
          if (voiceIcon) {
            if (loading) {
              voiceIcon.textContent = 'On';
            } else {
              voiceIcon.textContent = voiceEnabled ? 'On' : 'Off';
            }
          }
          if (voiceLabel) {
            voiceLabel.textContent = 'Voice';
          }
          if (voiceToggle) {
            voiceToggle.title = voiceEnabled ? 'Voice guide is ON - tap to turn off' : 'Tap to enable voice guide';
            if (voiceEnabled) {
              voiceToggle.classList.add('voice-on');
            } else {
              voiceToggle.classList.remove('voice-on');
            }
          }
        }

        function clearPendingRetry() {
          if (pendingRetry) {
            document.removeEventListener('click', pendingRetry, true);
            document.removeEventListener('touchstart', pendingRetry, true);
            document.removeEventListener('touchend', pendingRetry, true);
            document.removeEventListener('scroll', pendingRetry, true);
            pendingRetry = null;
          }
        }

        // Simple hash for browser cache keys
        function voiceHash(s) {
          for (var h = 0, i = 0; i < s.length; i++)
            h = ((h << 5) - h + s.charCodeAt(i)) & 0x7fffffff;
          return h.toString(36);
        }

        // Fetch audio with browser-side caching (instant on revisit)
        async function fetchVoiceAudio(text) {
          var cacheKey = '/ph-voice/' + voiceHash(text);

          // Try browser Cache API first — zero network, instant
          if ('caches' in window) {
            try {
              var cache = await caches.open('ph-voice-v1');
              var hit = await cache.match(cacheKey);
              if (hit) return await hit.blob();

              // Not cached — fetch from server and cache for next time
              var resp = await fetch('/api/speak', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text })
              });
              if (!resp.ok) throw new Error('TTS failed');
              cache.put(cacheKey, resp.clone());
              return await resp.blob();
            } catch (e) { /* fallthrough to direct fetch */ }
          }

          // Fallback: direct fetch (no caching)
          var resp = await fetch('/api/speak', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: text })
          });
          if (!resp.ok) throw new Error('TTS failed');
          return await resp.blob();
        }

        async function speak(text) {
          if (!voiceEnabled || !text) return;

          clearPendingRetry();
          stopSpeaking();

          try {
            isSpeaking = true;
            updateVoiceUI(true);

            var audioBlob = await fetchVoiceAudio(text);
            if (!voiceEnabled) { isSpeaking = false; updateVoiceUI(false); return; }

            var audioUrl = URL.createObjectURL(audioBlob);
            currentAudio = new Audio(audioUrl);

            currentAudio.onended = function() {
              isSpeaking = false;
              updateVoiceUI(false);
              URL.revokeObjectURL(audioUrl);
            };

            currentAudio.onerror = function() {
              isSpeaking = false;
              updateVoiceUI(false);
            };

            updateVoiceUI(false);

            try {
              await currentAudio.play();
            } catch (playErr) {
              // Mobile autoplay blocked — audio is loaded, plays INSTANTLY on first tap
              isSpeaking = false;

              var queuedAudio = currentAudio;
              pendingRetry = function(e) {
                if (voiceToggle && voiceToggle.contains(e.target)) return;
                clearPendingRetry();
                if (!voiceEnabled || !queuedAudio) return;
                isSpeaking = true;
                updateVoiceUI(false);
                queuedAudio.play().then(function() {
                  // playing
                }).catch(function() {
                  isSpeaking = false;
                  updateVoiceUI(false);
                });
              };
              // Listen on every gesture type so ANY interaction triggers it
              document.addEventListener('click', pendingRetry, true);
              document.addEventListener('touchstart', pendingRetry, true);
              document.addEventListener('touchend', pendingRetry, true);
              document.addEventListener('scroll', pendingRetry, { once: true, passive: true });
            }

          } catch (err) {
            console.error('Voice guide error:', err);
            isSpeaking = false;
            updateVoiceUI(false);
          }
        }

        function stopSpeaking() {
          if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
          }
          isSpeaking = false;
        }

        function toggleVoice() {
          voiceEnabled = !voiceEnabled;
          localStorage.setItem('ph-voice-guide', voiceEnabled ? 'true' : 'false');
          localStorage.setItem('ph-voice-decided', 'true');
          clearPendingRetry();
          updateVoiceUI(false);

          if (voiceEnabled) {
            speakPageGuidance();
          } else {
            stopSpeaking();
          }
        }

        function speakPageGuidance() {
          if (!voiceEnabled) return;
          var guidanceEl = document.getElementById('voiceGuidance');
          if (guidanceEl && guidanceEl.dataset.message) {
            speak(guidanceEl.dataset.message);
          }
        }

        // Initialize voice
        updateVoiceUI(false);

        if (voiceToggle) {
          voiceToggle.addEventListener('click', toggleVoice);
        }

        // Start voice IMMEDIATELY — no delay, fetch begins at page load
        // Browser cache makes this instant on revisited pages
        if (voiceEnabled) {
          speakPageGuidance();
        }

        // Make speak function globally available
        window.phSpeak = speak;
        window.phVoiceEnabled = function() { return voiceEnabled; };
        window.phStopSpeaking = stopSpeaking;
      })();
    </script>
  </body>
</html>
